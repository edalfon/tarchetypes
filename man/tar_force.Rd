% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tar_force.R
\name{tar_force}
\alias{tar_force}
\title{Target with a custom condition to force execution.}
\usage{
tar_force(
  name,
  command,
  force,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  template = targets::tar_option_get("template"),
  deployment = targets::tar_option_get("deployment"),
  priority = 0,
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue")
)
}
\arguments{
\item{name}{Character of length 1, name of the target.}

\item{command}{Similar to the \code{command} argument of \code{\link[targets:tar_target]{tar_target()}} except
the object must already be an expression instead of
informally quoted code.
\code{base::expression()} and \code{base::quote()} can produce such objects.}

\item{force}{R code for the condition that forces a build.
If it evaluates to \code{TRUE}, then your work will run during \code{tar_make()}.}

\item{tidy_eval}{Whether to invoke tidy evaluation
(e.g. the \verb{!!} operator from \code{rlang}) as soon as the target is defined
(before \code{tar_make()}). Applies to arguments \code{command} and \code{force}.}

\item{packages}{Character vector of packages to load right before
the target builds. Use \code{tar_option_set()} to set packages
globally for all subsequent targets you define.}

\item{library}{Character vector of library paths to try
when loading \code{packages}.}

\item{format}{Optional storage format for the target's return value.
With the exception of \code{format = "file"}, each target
gets a file in \verb{_targets/objects}, and each format is a different
way to save and load this file.
Possible formats:
\itemize{
\item \code{"file"}: A dynamic file. To use this format,
the target needs to manually identify or save some data
and return a character vector of paths
to the data. Those paths must point to files or directories,
and they must not contain characters \code{|} or \code{*}.
Then, \code{targets} automatically checks those files and cues the
appropriate build decisions if those files are out of date.
\item \code{"rds"}: Default, uses \code{saveRDS()} and \code{readRDS()}. Should work for
most objects, but slow.
\item \code{"qs"}: Uses \code{qs::qsave()} and \code{qs::qread()}. Should work for
most objects, much faster than \code{"rds"}.
\item \code{"fst"}: Uses \code{fst::write_fst()} and \code{fst::read_fst()}.
Much faster than \code{"rds"}, but the value must be
a data frame.
\item \code{"fst_dt"}: Same as \code{"fst"}, but the value is a \code{data.table}.
\item \code{"fst_tbl"}: Same as \code{"fst"}, but the value is a \code{tibble}.
\item \code{"keras"}: Uses \code{keras::save_model_hdf5()} and
\code{keras::load_model_hdf5()}. The value must be a Keras model.
}}

\item{iteration}{Character of length 1, name of the iteration mode
of the target. Choices:
\itemize{
\item \code{"vector"}: branching happens with \code{vectors::vec_slice()} and
aggregation happens with \code{vctrs::vec_c()}.
\item \code{"list"}, branching happens with \verb{[[]]} and aggregation happens with
\code{list()}.
\item \code{"group"}: \code{dplyr::group_by()}-like functionality to branch over
subsets of a data frame. The target's return value must be a data
frame with a special \code{tar_group} column of consecutive integers
from 1 through the number of groups. Each integer designates a group,
and a branch is created for each collection of rows in a group.
See the \code{\link[targets:tar_group]{tar_group()}} function to see how you can
create the special \code{tar_group} column with \code{dplyr::group_by()}.
}}

\item{error}{Character of length 1, what to do if the target
runs into an error. If \code{"stop"}, the whole pipeline stops
and throws an error. If \code{"continue"}, the error is recorded,
but the pipeline keeps going.}

\item{memory}{Character of length 1, memory strategy.
If \code{"persistent"}, the target stays in memory
until the end of the pipeline.
If \code{"transient"}, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.}

\item{template}{Relevant to \code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}} only.
Named list of values to fill in the \code{clustermq} template file.
Unsupported for now. May be supported in the future if
\code{clustermq} ever supports heterogeneous workers with varying
resource requirements. In the meantime, use the \code{template}
argument of \code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}}.}

\item{deployment}{Character of length 1, only relevant to
\code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}} and \code{\link[targets:tar_make_future]{tar_make_future()}}. If \code{"remote"},
the target builds on a remote parallel worker. If \code{"local"},
the target builds on the host machine / process managing the pipeline.}

\item{priority}{Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get built earlier.}

\item{resources}{Relevant to \code{\link[targets:tar_make_future]{tar_make_future()}} only.
A named list of resources passed to \code{future::future()} when
defining a new worker.}

\item{storage}{Character of length 1, only relevant to
\code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}} and \code{\link[targets:tar_make_future]{tar_make_future()}}.
If \code{"local"}, the target's return value is sent back to the
host machine and saved locally. If \code{"remote"}, the remote worker
saves the value.}

\item{retrieval}{Character of length 1, only relevant to
\code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}} and \code{\link[targets:tar_make_future]{tar_make_future()}}.
If \code{"local"}, the target's dependencies are loaded on the host machine
and sent to the remote worker before the target builds.
If \code{"remote"}, the remote worker loads the targets dependencies.}

\item{cue}{An optional object from \code{tar_cue()} to customize the
rules that decide whether the target is up to date.}
}
\value{
A list of targets: one to indicate whether the custom
condition is met, and another to respond to it and do your
actual work.
}
\description{
Create a target that always runs if a user-defined
condition rule is met.
}
\details{
\code{tar_force()} creates a target that always runs
when a custom condition is met. The implementation builds
on top of \code{\link[=tar_change]{tar_change()}}. Thus, a pair of targets is created:
an upstream auxiliary target to indicate the custom condition
and a downstream target that responds to it and does your work.
}
\examples{
\dontrun{
# Without loss of generality,
tar_force(your_target, run_stuff(), force = should_run())
# is equivalent to:
tar_change(
  your_target,
  run_stuff(),
  change = tarchetypes::tar_force_change(should_run)
)
# tar_force_change() is an internal function that converts
# your custom condition into a special indicator for tar_change().
# Try it out.
targets::tar_dir({
targets::tar_script({
  tar_pipeline(
    tarchetypes::tar_force(x, tempfile(), force = 1 > 0)
  )
})
targets::tar_make()
targets::tar_make()
})
}
}
