% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tar_render_raw.R
\name{tar_render_raw}
\alias{tar_render_raw}
\title{Target with an R Markdown document (raw version).}
\usage{
tar_render_raw(
  name,
  path,
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  error = targets::tar_option_get("error"),
  deployment = "main",
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  quiet = TRUE,
  render_arguments = quote(list())
)
}
\arguments{
\item{name}{Character of length 1, name of the target.}

\item{path}{Character string, file path to the R Markdown source file.
Must have length 1.}

\item{packages}{Character vector of packages to load right before
the target builds. Use \code{tar_option_set()} to set packages
globally for all subsequent targets you define.}

\item{library}{Character vector of library paths to try
when loading \code{packages}.}

\item{error}{Character of length 1, what to do if the target
runs into an error. If \code{"stop"}, the whole pipeline stops
and throws an error. If \code{"continue"}, the error is recorded,
but the pipeline keeps going.}

\item{deployment}{Character of length 1, only relevant to
\code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}} and \code{\link[targets:tar_make_future]{tar_make_future()}}. If \code{"worker"},
the target builds on a parallel worker. If \code{"main"},
the target builds on the host machine / process managing the pipeline.}

\item{priority}{Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get built earlier.
Only applies to \code{\link[targets:tar_make_future]{tar_make_future()}} and \code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}}
(not \code{\link[targets:tar_make]{tar_make()}}). \code{\link[targets:tar_make_future]{tar_make_future()}} with no extra settings is
a drop-in replacement for \code{\link[targets:tar_make]{tar_make()}} in this case.}

\item{resources}{A named list of computing resources. Uses:
\itemize{
\item Template file wildcards for \code{future::future()} in \code{\link[targets:tar_make_future]{tar_make_future()}}.
\item Template file wildcards \code{clustermq::workers()} in \code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}}.
\item Custom target-level \code{future::plan()}, e.g.
\code{resources = list(plan = future.callr::callr)}.
\item Custom \code{curl} handle if \code{format = "url"},
e.g. \code{resources = list(handle = curl::new_handle())}.
\item Custom preset for \code{qs::qsave()} if \code{format = "qs"}, e.g.
\code{resources = list(handle = "archive")}.
\item Custom compression level for \code{fst::write_fst()} if
\code{format} is \code{"fst"}, \code{"fst_dt"}, or \code{"fst_tbl"}, e.g.
\code{resources = list(compress = 100)}.
\item AWS bucket and prefix for the \code{"aws_"} formats, e.g.
\code{resources = list(bucket = "your-bucket", prefix = "folder/name")}.
\code{bucket} is required for AWS formats. See the cloud computing chapter
of the manual for details.
}}

\item{retrieval}{Character of length 1, only relevant to
\code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}} and \code{\link[targets:tar_make_future]{tar_make_future()}}.
If \code{"main"}, the target's dependencies are loaded on the host machine
and sent to the worker before the target builds.
If \code{"worker"}, the worker loads the targets dependencies.}

\item{cue}{An optional object from \code{tar_cue()} to customize the
rules that decide whether the target is up to date.}

\item{quiet}{An option to suppress printing of the pandoc command line.}

\item{render_arguments}{Optional language object with a list
of named arguments to \code{rmarkdown::render()}.
Cannot be an expression object.
(Use \code{quote()}, not \code{expression()}.)
The reason for quoting is that these arguments may depend on
upstream targets whose values are not available at
the time the target is defined, and because \code{tar_render_raw()}
is the "raw" version of a function, we want to avoid
all non-standard evaluation.}
}
\value{
A \code{tar_target()} object with \code{format = "file"}.
When this target runs, it returns a character vector
of file paths. The first file paths are the output files
(returned by \code{rmarkdown::render()}) and the R Markdown
source file is last. But unlike \code{rmarkdown::render()},
all returned paths are \emph{relative} paths to ensure portability
(so that the project can be moved from one file system to another
without invalidating the target).
}
\description{
Shorthand to include an R Markdown document in a
\code{targets} pipeline (raw version)
}
\details{
\code{tar_render_raw()} is just like \code{tar_render()}
except that it uses standard evaluation. The \code{name} argument
is a character vector, and the \code{render_arguments} argument
is a language object.
}
\examples{
if (identical(Sys.getenv("TARCHETYPES_LONG_EXAMPLES"), "true")) {
targets::tar_dir({
# Unparameterized R Markdown:
lines <- c(
  "---",
  "title: report",
  "output_format: html_document",
  "---",
  "",
  "```{r}",
  "targets::tar_read(data)",
  "```"
)
writeLines(lines, "report.Rmd")
targets::tar_script({
  library(tarchetypes)
  list(
    tar_target(data, data.frame(x = seq_len(26), y = letters)),
    tar_render_raw("report", "report.Rmd")
  )
})
targets::tar_make()
# browseURL("report.html") # View the report.
# Parameterized R Markdown:
lines <- c(
  "---",
  "title: report",
  "output_format: html_document",
  "params:",
  "  your_param: \"default value\"",
  "---",
  "",
  "```{r}",
  "print(params$your_param)",
  "```"
)
writeLines(lines, "report.Rmd")
targets::tar_script({
  library(tarchetypes)
  list(
    tar_target(data, data.frame(x = seq_len(26), y = letters)),
    tar_render_raw(
      "report",
      "report.Rmd",
      render_arguments = quote(list(params = list(your_param = data)))
    )
  )
})
# targets::tar_visnetwork() # The report should be connected to the data.
targets::tar_make()
# browseURL("report.html") # View the report.
})
}
}
