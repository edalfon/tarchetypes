% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tar_knit.R
\name{tar_knit}
\alias{tar_knit}
\title{Alternative to \code{tar_target()} for a \code{knitr} document.}
\usage{
tar_knit(
  name,
  path,
  packages = targets::tar_option("packages", (.packages())),
  library = targets::tar_option("library"),
  error = targets::tar_option("error", "stop"),
  deployment = targets::tar_option("deployment", "local"),
  priority = 0,
  template = targets::tar_option("template", NULL),
  resources = targets::tar_option("resources", list()),
  retrieval = targets::tar_option("retrieval", "local"),
  cue = targets::tar_option("cue", NULL),
  quiet = TRUE,
  ...
)
}
\arguments{
\item{name}{Character of length 1, name of the target.}

\item{path}{Character string, file path to the \code{knitr} source file.
Must have length 1.}

\item{packages}{Character vector of packages to load right before
the target builds. Use \code{tar_options()} to set packages
globally for all subsequent targets you define.}

\item{library}{Character vector of library paths to try
when loading \code{packages}.}

\item{error}{Character of length 1, what to do if the target
runs into an error. If \code{"stop"}, the whole pipeline stops
and throws an error. If \code{"continue"}, the error is recorded,
but the pipeline keeps going.}

\item{deployment}{Character of length 1, only relevant to
\code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}} and \code{\link[targets:tar_make_future]{tar_make_future()}}. If \code{"remote"},
the target builds on a remote parallel worker. If \code{"local"},
the target builds on the host machine / process managing the pipeline.}

\item{priority}{Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get built earlier.}

\item{template}{Relevant to \code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}} only.
Named list of values to fill in the \code{clustermq} template file.
Unsupported for now. May be supported in the future if
\code{clustermq} ever supports heterogeneous workers with varying
resource requirements. In the meantime, use the \code{template}
argument of \code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}}.}

\item{resources}{Relevant to \code{\link[targets:tar_make_future]{tar_make_future()}} only.
A named list of resources passed to \code{future::future()} when
defining a new worker.}

\item{retrieval}{Character of length 1, only relevant to
\code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}} and \code{\link[targets:tar_make_future]{tar_make_future()}}.
If \code{"local"}, the target's dependencies are loaded on the host machine
and sent to the remote worker before the target builds.
If \code{"remote"}, the remote worker loads the targets dependencies.}

\item{cue}{An optional object from \code{tar_cue()} to customize the
rules that decide whether the target is up to date.}

\item{quiet}{Boolean; suppress the progress bar and messages?}

\item{...}{Named arguments to \code{knitr::knit()}}
}
\value{
A \code{tar_target()} object with \code{format = "file"}.
When this target runs, it returns a character vector
of file paths. The first file paths are the output files
(returned by \code{knitr::knit()}) and the \code{knitr}
source file is last. But unlike \code{knitr::knit()},
all returned paths are \emph{relative} paths to ensure portability
(so that the project can be moved from one file system to another
without invalidating the target).
}
\description{
Shorthand to include \code{knitr} document in a
\code{targets} pipeline.
}
\details{
\code{tar_knit()} is an alternative to \code{tar_target()} for
\code{knitr} reports that depend on other targets. The \code{knitr} source
should mention dependency targets with \code{tar_load()} and \code{tar_read()}
in the active code chunks (which also allows you to knit the report
outside the pipeline if the \verb{_targets/} data store already exists).
Then, \code{tar_knit()} defines a special kind of target. It
1. Finds all the \code{tar_load()}/\code{tar_read()} dependencies in the report
and inserts them into the target's command.
This enforces the proper dependency relationships.
2. Sets \code{format = "file"} (see \code{tar_target()}) so \code{targets}
watches the files at the returned paths and reruns the report
if those files change.
3. Configures the target's command to return both the output
report files and the input source file. All these file paths
are relative paths so the project stays portable.
4. Forces the report to run in the user's current working directory
instead of the working directory of the report.
5. Sets convenient default options such as \code{deployment = "local"}
in the target and \code{quiet = TRUE} in \code{knitr::knit()}.
}
\examples{
\dontrun{
targets::tar_dir({
lines <- c(
  "---",
  "title: report",
  "output_format: html_document",
  "---",
  "",
  "```{r}",
  "targets::tar_read(data)",
  "```"
)
writeLines(lines, "report.Rmd")
targets::tar_script({
  library(tarchetypes)
  tar_pipeline(
    tar_target(data, data.frame(x = seq_len(26), y = letters)),
    tar_knit(report, "report.Rmd")
  )
})
targets::tar_make()
})
}
}
